/**********************************************************************************************************************
 * \file main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "cyhal.h"
#include "cybsp.h"
#include "cy_retarget_io.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* Value for temporarily disabling the APs */
#define CPUSS_AP_CTL_DISABLE               0x00000000
/* Value for enabling the APs */
#define CPUSS_AP_CTL_ENABLE                0x00000007

/* Maximum number of times password is checked */
#define MAX_PASSWORD_CHECK                 3U
/* Size of the signature in bytes */
#define PASSWORD_SIGNATURE_SIZE_BYTES      128U

/* For user button and LED */
#define USER_LED_PORT_ADDR                 Cy_GPIO_PortToAddr(CYHAL_GET_PORT(CYBSP_USER_LED))
#define USER_LED_PIN                       CYHAL_GET_PIN(CYBSP_USER_LED)
#define USER_BTN_PORT_ADDR                 Cy_GPIO_PortToAddr(CYHAL_GET_PORT(CYBSP_USER_BTN))
#define USER_BTN_PIN                       CYHAL_GET_PIN(CYBSP_USER_BTN)
#define USER_BTN_IRQ                       (IRQn_Type)(ioss_interrupts_gpio_dpslp_0_IRQn + CYHAL_GET_PORT(CYBSP_USER_BTN))
#define USER_BTN_IRQ_PRIORITY              7U

/* Number of bits in a byte*/
#define BITS_PER_BYTE                      8U

/* Shift value for CPU IRQ number ('intSrc' of cy_stc_sysint_t consists of CPU IRQ number and system IRQ number) */
#define CPU_IRQ_NUMBER_SHIFT               16
#define CPU_IRQ_NUM                        (IRQn_Type)NvicMux3_IRQn

/* Delay for LED toggling */
#define LED_TOGGLE_DELAY_MS                200U

/*********************************************************************************************************************/
/*-------------------------------------------------Global Variables--------------------------------------------------*/
/*********************************************************************************************************************/
/* Variable to store the encrypted signature of the password sent by the user over UART */
uint8_t g_encryptedSignature[PASSWORD_SIGNATURE_SIZE_BYTES];

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
/* Modulus - Part of a public key in big endian format */
static uint8_t modulus[PASSWORD_SIGNATURE_SIZE_BYTES] =
{
    0xc5,0x98,0xb6,0xe7,0xb8,0x02,0x87,0x90,0xfa,0x77,0x75,0x1e,0xcf,0x55,0x30,0x8a,
    0xd0,0x73,0x46,0x3e,0x97,0x23,0x89,0xf1,0xc2,0x22,0xdb,0xa9,0xf5,0x99,0xeb,0xd5,
    0x88,0xbf,0x2a,0x87,0x74,0x89,0xc9,0x79,0x52,0x37,0xd1,0x33,0x86,0xce,0x82,0x3f,
    0xc4,0x06,0x91,0x42,0x0f,0x91,0x09,0x17,0xb8,0x41,0xd0,0x47,0x5f,0xfe,0xaf,0x34,
    0x51,0x68,0xd4,0xbe,0x4a,0xc7,0x6c,0xd7,0x43,0xe5,0xa6,0x21,0x4e,0xab,0x4f,0x9e,
    0x05,0x72,0x9a,0x9a,0x02,0xc1,0x0e,0x78,0x72,0x53,0x90,0x65,0x93,0x90,0x49,0x67,
    0x3f,0x21,0xc4,0x0e,0x4b,0xf2,0xdc,0xf0,0x8f,0xd3,0x09,0x6f,0x0c,0xc9,0x91,0x6e,
    0xbf,0xfb,0xac,0x76,0x45,0xf4,0xf3,0x48,0xb1,0xf4,0x33,0x0b,0xde,0x75,0x90,0xf9
};

/* Exponent (also called e) - Part of public key in big endian format */
static uint8_t publicExponent[] =
{
    0x01, 0x00, 0x01
};

/* Variable to indicate if DAP is enabled */
static bool isAccessPortEnabled = true;

/* Variable to indicate if the password needs to be checked */
static bool checkPassword = false;

/* The plain text that is later used to calculate the HASH in the signature. This acts like a password */
const uint8_t PLAIN_TEXT[] = "hogehogehogehogehogehogehogehogehogehogehogehogehogehogehogehogehogehogehogehogehogehoge"
        "hogehogehogehogehogehogehogehogehogehoge";

/* Structure to store RSA public key data */
const cy_stc_crypto_rsa_pub_key_t PUBLIC_KEY =
{
    .moduloPtr          = modulus,
    .moduloLength       = PASSWORD_SIGNATURE_SIZE_BYTES * BITS_PER_BYTE,
    .pubExpPtr          = publicExponent,
    .pubExpLength       = 17,
    .barretCoefPtr      = NULL,
    .inverseModuloPtr   = NULL,
    .rBarPtr            = NULL,
};

/* Configuration structure for button interrupt */
const cy_stc_sysint_t IRQ_BUTTON_CONFIG =
{
    .intrSrc = ((CPU_IRQ_NUM << CPU_IRQ_NUMBER_SHIFT) | USER_BTN_IRQ),
    .intrPriority = USER_BTN_IRQ_PRIORITY,
};

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
static void handleGPIOinterrupt(void);
static void checkUARTpassword(void);
static cy_en_crypto_rsa_ver_result_t verifyRSAsignature(void);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/**********************************************************************************************************************
 * Function Name: handleGPIOinterrupt
 * Summary:
 *  Handles the GPIO interrupt when the user button is pressed.
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void handleGPIOinterrupt(void)
{
    /*Disable the APs */
    CY_SET_REG32(&CPUSS->AP_CTL, CPUSS_AP_CTL_DISABLE);

    /* Turn off the LED */
    Cy_GPIO_Write(USER_LED_PORT_ADDR, USER_LED_PIN, CYBSP_LED_STATE_OFF);

    /* Clear the interrupt */
    Cy_GPIO_ClearInterrupt(USER_BTN_PORT_ADDR, USER_BTN_PIN);

    isAccessPortEnabled = false;
    checkPassword = true;
}

/**********************************************************************************************************************
 * Function Name: checkUARTpassword
 * Summary:
 *  Receives password sent over UART. When PASSWORD_SIGNATURE_SIZE_BYTES are received, the password is verified.
 *  If incorrect password is received MAX_PASSWORD_CHECK times, the user button interrupt is disabled to indicate
 *  the device is locked. If password is correct, the APs are enabled.
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
void checkUARTpassword(void)
{
    uint8_t uartReadValue;
    uint16_t uartCharCount = 0;
    uint8_t passwordCheckCount = 0;
    cy_en_crypto_rsa_ver_result_t verifyResult;

    printf(">> Debugger Locked!!! Enter the correct 128 byte password to unlock DAP.\r\n\r\n");

    while (passwordCheckCount < MAX_PASSWORD_CHECK)
    {
        /* Code to handle data reception */
        if (CY_RSLT_SUCCESS == cyhal_uart_getc(&cy_retarget_io_uart_obj, &uartReadValue, 0UL))
        {
            if (CY_RSLT_SUCCESS == cyhal_uart_putc(&cy_retarget_io_uart_obj, uartReadValue))
            {
                /* Store the received character to decrypt it later */
                g_encryptedSignature[uartCharCount] = uartReadValue;
                uartCharCount++;
            }
            else
            {
                CY_ASSERT(0);
            }
        }
        else
        {
            CY_ASSERT(0);
        }

        /* Check if the received character count has reached PASSWORD_SIGNATURE_SIZE_BYTES */
        if (uartCharCount == PASSWORD_SIGNATURE_SIZE_BYTES)
        {
            /* Perform RSA decryption and signature verification */
            verifyResult = verifyRSAsignature();

            /* Check the verification result */
            if (verifyResult == CY_CRYPTO_RSA_VERIFY_SUCCESS)
            {
                /* Enable the APs */
                CY_SET_REG32(&CPUSS->AP_CTL, CPUSS_AP_CTL_ENABLE);

                isAccessPortEnabled = true;

                printf("\r\n\r\n>> Correct Password! Debugger Unlocked."
                        " You can now halt the core and resume debug. \r\n\r\n");
                break;
            }
            else
            {
                /* Increment count for incorrect password */
                passwordCheckCount++;
                printf("\r\n\r\n>> Incorrect Password! %u attempt(s) remaining \r\n\r\n",
                        (MAX_PASSWORD_CHECK - passwordCheckCount));
            }

            if (passwordCheckCount == MAX_PASSWORD_CHECK)
            {
                /* Disable user button interrupt - not forwarded to CPU interrupt controller */
                Cy_GPIO_SetInterruptMask(USER_BTN_PORT_ADDR, USER_BTN_PIN, 0UL);
                printf(">> DAP is locked. Restart device and debugger again. \r\n\r\n");
            }
            uartCharCount = 0;
        }
    }

    return;
}

/**********************************************************************************************************************
 * Function Name: verifyRSAsignature
 * Summary:
 *  Computes hash of the plain text using SHA-256 algorithm. The encrypted password received over UART is decrypted
 *  using RSA public key. The computed hash/digest is verified against the decrypted signature for a match.
 * Parameters:
 *  none
 * Return:
 *  verifyResult - status of verification
 **********************************************************************************************************************
 */
cy_en_crypto_rsa_ver_result_t verifyRSAsignature(void)
{
    cy_en_crypto_status_t cryptoStatus = CY_CRYPTO_NOT_INITIALIZED;
    cy_en_crypto_rsa_ver_result_t verifyResult;
    uint8_t decryptedSignature[PASSWORD_SIGNATURE_SIZE_BYTES];
    uint8_t calculatedHash[CY_CRYPTO_SHA256_DIGEST_SIZE];

    /* Convert endianness to little endian */
    Cy_Crypto_InvertEndianness(g_encryptedSignature, sizeof(g_encryptedSignature));

    /* Compute hash/digest of the plain text using SHA-256 algorithm */
    cryptoStatus = Cy_Crypto_Core_Sha(CRYPTO, PLAIN_TEXT, sizeof(PLAIN_TEXT) - 1UL,
            calculatedHash, CY_CRYPTO_MODE_SHA256);
    CY_ASSERT(CY_CRYPTO_SUCCESS == cryptoStatus);

    /* Decrypt the signature with public key */
    cryptoStatus = Cy_Crypto_Core_Rsa_Proc(CRYPTO, &PUBLIC_KEY, g_encryptedSignature,
            sizeof(g_encryptedSignature),decryptedSignature);
    CY_ASSERT(CY_CRYPTO_SUCCESS == cryptoStatus);

    /* The calculated result is little endian. Convert endianness to big endian */
    Cy_Crypto_InvertEndianness(decryptedSignature, sizeof(decryptedSignature));

    /* Verify decrypted signature with calculated digest */
    cryptoStatus = Cy_Crypto_Core_Rsa_Verify(CRYPTO, &verifyResult, CY_CRYPTO_MODE_SHA256, calculatedHash,
            decryptedSignature, sizeof(decryptedSignature));
    CY_ASSERT(CY_CRYPTO_SUCCESS == cryptoStatus);

    /* Convert endianness back to big endian */
    Cy_Crypto_InvertEndianness(g_encryptedSignature, sizeof(g_encryptedSignature));

    return verifyResult;
}

/**********************************************************************************************************************
 * Function Name: main
 * Summary:
 *  This is the main function.
 * Parameters:
 *  none
 * Return:
 *  int
 **********************************************************************************************************************
 */
int main(void)
{
    cy_rslt_t result;

    #if defined(CY_DEVICE_SECURE)
        cyhal_wdt_t wdt_obj;
        /* Clear Watch Dog timer so that it doesn't trigger a reset */
        result = cyhal_wdt_init(&wdt_obj, cyhal_wdt_get_max_timeout_ms());
        CY_ASSERT(CY_RSLT_SUCCESS == result);
        cyhal_wdt_free(&wdt_obj);
    #endif

    /* Initialize the device and board peripherals */
    result = cybsp_init();

    /* Board init failed. Stop program execution */
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* Initialize retarget-io to use the debug UART port */
    result = cy_retarget_io_init(CYBSP_DEBUG_UART_TX, CYBSP_DEBUG_UART_RX,
            CY_RETARGET_IO_BAUDRATE);

    /* retarget-io init failed. Stop program execution */
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* ------------------------------------------------------------------------------------------
     *                               GPIO and Interrupt Initialization
     * ----------------------------------------------------------------------------------------*/
    /* Initialize user LED */
    Cy_GPIO_Pin_FastInit(USER_LED_PORT_ADDR, USER_LED_PIN, CY_GPIO_DM_STRONG_IN_OFF, 0U, HSIOM_SEL_GPIO);

    /* Initialize user button 1 */
    Cy_GPIO_Pin_FastInit(USER_BTN_PORT_ADDR, USER_BTN_PIN, CY_GPIO_DM_PULLUP, 1U, HSIOM_SEL_GPIO);

    /* Set the interrupt edge */
    Cy_GPIO_SetInterruptEdge(USER_BTN_PORT_ADDR, USER_BTN_PIN, CY_GPIO_INTR_FALLING);

    /* Set the interrupt mask */
    Cy_GPIO_SetInterruptMask(USER_BTN_PORT_ADDR, USER_BTN_PIN, 1);

    /*Initialize the  interrupt with its interrupt handler */
    if (Cy_SysInt_Init(&IRQ_BUTTON_CONFIG, &handleGPIOinterrupt) != CY_SYSINT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* Enable CPU interrupt. */
    NVIC_EnableIRQ(CPU_IRQ_NUM);

    /* ------------------------------------------------------------------------------------------
     *                               Crypto Block Initialization
     * ----------------------------------------------------------------------------------------*/
    /* Enable Crypto IP */
    Cy_Crypto_Core_Enable(CRYPTO);

    /* Convert endianness to little as Crypto functions used here treat keys and message in little endian format */
    Cy_Crypto_InvertEndianness(modulus, sizeof(modulus));
    Cy_Crypto_InvertEndianness(publicExponent, sizeof(publicExponent));

    /* \x1b[2J\x1b[;H - ANSI ESC sequence for clear screen */
    printf("\x1b[2J\x1b[;H");
    printf("********************************************************************************\r\n");
    printf("                             SECURED DAP Control\r\n");
    printf("********************************************************************************\r\n\r\n");

    printf(">> Press User Button 1 to disable DAP.\r\n\r\n");

    __enable_irq();

    for (;;)
    {
        if (isAccessPortEnabled == false)
        {
            if (checkPassword == true)
            {
                checkPassword = false;

                /* Check password sent over UART and verify it */
                checkUARTpassword();
            }
        }
        else
        {
            /* Toggle LED when the APs are enabled */
            Cy_GPIO_Inv(USER_LED_PORT_ADDR, USER_LED_PIN);
        }
        Cy_SysLib_Delay(LED_TOGGLE_DELAY_MS);
    }
}
